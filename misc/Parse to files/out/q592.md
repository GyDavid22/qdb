Test yourself by guessing the output of the following code snippets.

-   String s1 = \"abc\";

> String s2 = \"abc\";
>
> System.out.println(\"s1 == s2 is:\" + s1 == s2);
>
> Output
>
> false
>
> The output of the given statement is false because the + operator has
> a higher precedence than the == operator. So the given expression is
> evaluated to "s1 == s2 is:abc" == "abc", which is false.

-   String s3 = \"JournalDev\";

> int start = 1;
>
> char end = 5;
>
> System.out.println(s3.substring(start, end));
>
> Output
>
> ourn
>
> The output of the given statement is ourn. The first character is
> automatically type cast to int. Then, since the first character index
> is 0, it will start from o and print until n. Note that the String
> substring method creates a substring that begins at index start and
> extends to the character at index end - 1.

-   HashSet shortSet = new HashSet();

> for (short i = 0; i \< 100; i++) {
>
> \>shortSet.add(i);
>
> \>shortSet.remove(i - 1);
>
> }
>
> System.out.println(shortSet.size());
>
> Output
>
> 100
>
> The size of the shortSet is 100. The autoboxing feature in Java means
> that the expression i, which has the primitive type short, converts to
> a Short object. Similarly, the expression i - 1 has the primitive type
> int and is autoboxed to an Integer object. Since there is no Integer
> object in the HashSet, nothing is removed and the size is 100.

-   try {

> \>if (flag) {
>
> \>\>while (true) {}
>
> \>} else {
>
> \>\>System.exit(1);
>
> \>}
>
> } finally {
>
> \>System.out.println(\"In Finally\");
>
> }
>
> Output
>
> No output. This code results in an infinite loop if the flag is true
> and the program exists if the flag is false. The finally block will
> never be reached.

-   String str = null;

> String str1=\"abc\";
>
> System.out.println(str1.equals(\"abc\") \|\| str.equals(null));
>
> Output
>
> Exception in thread \"main\" java.lang.NullPointerException: Cannot
> invoke \"String.equals(Object)\" because \"\<local1\>\" is null
>
> The given print statement will throw a java.lang.NullPointerException
> because the OR logical operator evaluates both the literals before
> returning the result. Since str is null, the .equals() method will
> throw an exception. Its always advisable to use short-circuit logical
> operators, such as \|\| and &&, which evaluate the literal values from
> left to right. In this case, since the first literal would return
> true, it would skip the second literal evaluation.

-   String x = \"abc\";

> String y = \"abc\";
>
> x.concat(y);
>
> System.out.print(x);
>
> Output
>
> abc
>
> The x.concat(y) creates a new string but is not assigned to x, so the
> value of x is not changed.

-   public class MathTest {

> \>public void main(String\[\] args) {
>
> \>\>int x = 10 \* 10 - 10;
>
> \>\>System.out.println(x);
>
> \>}
>
> }
>
> Output
>
> Error: Main method is not static in class MathTest, please define the
> main method as:
>
> public static void main(String\[\] args)
>
> While it might seem like this question is about the order of execution
> of the mathematical operators, the question is really about noticing
> that the main method wasn't declared static.

-   public class Test {

> \>public static void main(String\[\] args) {
>
> \>\>try {
>
> \>\>\>throw new IOException(\"Hello\");
>
> \>\>} catch (IOException \| Exception e) {
>
> \>\>\>System.out.println(e.getMessage());
>
> \>\>}
>
> \>}
>
> }
>
> Output
>
> Test.java:5: error: cannot find symbol
>
> \>\>\>throw new IOException(\"Hello\");
>
> \>\>\>\>\> \^
>
> symbol: class IOException
>
> location: class Test
>
> Test.java:6: error: cannot find symbol
>
> \>\>}catch(IOException \| Exception e) {
>
> \>\>\> \^
>
> symbol: class IOException
>
> location: class Test
>
> 2 errors
>
> This code results in a compile time error. The exception IOException
> is already caught by the alternative Exception.