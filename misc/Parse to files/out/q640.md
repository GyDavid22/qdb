Key here is to check whether candidate uses ArrayList's remove() or
Iterator's remove(). Here is the sample code which uses right way to
remove elements from ArrayList while looping over and avoids
ConcurrentModificationException.

Here is the Java program to demonstrate one scenario where you get the
ConcurrentModificationException even if just one thread is modifying the
ArrayList. In this example, we are looping over ArrayList using advanced
for loop and removing selected elements, but because we are using
ArrayList's remove() method.

/\*\*

\* Java Program to demonstrate how to deal with

\* ConcurrentModificationException.

\* Unlike the name suggests, this error can come even if only

\* one thread is modifying the collection e.g. List.

\* It happens when you modify collection

\* while iterating over it e.g. adding new element or removing elements.

\*

\* If you want to remove elements while traversing list then

\* make sure you use Iterator's remove() method or not ArrayList's
remove()

\* method() to avoid ConcurrentModificationExcetpion.

\*

\* \@author WINDOWS 8

\*

\*/

public class ConcurrentModExceptionDemo{

>public static void main(String args\[\]) {

>>List\<String> listOfPhones = new ArrayList\<String>(Arrays.asList(

>>>>\"iPhone 6S\", \"iPhone 6\", \"iPhone 5\", \"Samsung Galaxy 4\",

>>>> \"Lumia Nokia\"));

>>System.out.println(\"list of phones: \" + listOfPhones);

>>// Iterating and removing objects from list

>>// This is wrong way, will throw ConcurrentModificationException

>>for(String phone : listOfPhones){

>>>if(phone.startsWith(\"iPhone\")){

>>> // listOfPhones.remove(phone); // will throw exception

>>>}

>>}

>>// The Right way, iterating elements using Iterator's remove()
method

>>for(Iterator\<String> itr = listOfPhones.iterator();

>>>>>>>> itr.hasNext();){>>>

>>>String phone = itr.next();>>>

>>>if(phone.startsWith(\"iPhone\")){

>>>>// listOfPhones.remove(phone); // wrong again

>>>>itr.remove(); // right call

>>>}

>>}

>>System.out.println(\"list after removal: \" + listOfPhones);

>}

}

Output :

list of phones: \[iPhone 6S, iPhone 6, iPhone 5, Samsung Galaxy 4,

Lumia Nokia\]

list after removal: \[Samsung Galaxy 4, Lumia Nokia\]

If you uncomment the commented code in the first loop and second loop,
you will get the following exception:

Exception in thread \"main\" java.util.ConcurrentModificationException

at java.util.ArrayList\$Itr.checkForComodification(Unknown Source)

at java.util.ArrayList\$Itr.next(Unknown Source)

at dto.ReverseArrayInPlace.main(ReverseArrayInPlace.java:28)

because we are using ArrayList's remove() method. In the second
example, we have used the remove() method of Iterator and that's why we
are successfully able to delete selected elements from the ArrayList
without ConcurrentModificationException.