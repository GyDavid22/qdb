-   The term reflection is used for describing the inspection capability
of a code on other code either of itself or of its system and modify
it during runtime.

-   Consider an example where we have an object of unknown type and we
have a method 'fooBar()' which we need to call on the object. The
static typing system of Java doesn't allow this method invocation
unless the type of the object is known beforehand. This can be
achieved using reflection which allows the code to scan the object
and identify if it has any method called "fooBar()" and only then
call the method if needed.

Method methodOfFoo = fooObject.getClass().getMethod(\"fooBar\", null);

methodOfFoo.invoke(fooObject, null);

-   Using reflection has its own cons:

-   Speed --- Method invocations due to reflection are about three
times slower than the direct method calls.

-   Type safety --- When a method is invoked via its reference
wrongly using reflection, invocation fails at runtime as it is
not detected at compile/load time.

-   Traceability --- Whenever a reflective method fails, it is very
difficult to find the root cause of this failure due to a huge
stack trace. One has to deep dive into the invoke() and proxy()
method logs to identify the root cause.

-   Hence, it is advisable to follow solutions that don't involve
reflection and use this method as a last resort.

Reflection is the process of examining or modifying the runtime behavior
of a class at runtime. The java.lang.Class class provides various
methods that can be used to get metadata, examine and change the runtime
behavior of a class. The java.lang and java.lang.reflect packages
provide classes for java reflection. It is used in:

-   IDE (Integrated Development Environment), e.g., Eclipse, MyEclipse,
NetBeans.

-   Debugger

-   Test Tools, etc.